"""
Generate JSON test file from QFT XML test files.

@author: Martino Ferrari
@email: manda.mgf@gmail.com
"""
import argparse
from lxml import etree
from enum import Enum
import json
import sys


class VariableMode(Enum):
    """Simple enum for Variable Mode."""
    INPUT = 1
    OUTPUT = 0


def extract_path(path):
    """
    Extracts the project relative path from a generic path.

    Paramters
    ---------
    - path: test file path

    Returns
    -------
    - string: if it is relative to the snap gui project otherwise None
    """
    if path.startswith('snap/'):
        return path
    if '/snap/' in path:
        i = path.find('/snap/')
        return path[i+1:]
    return None


def check_input(value, def_value):
    """Checks return value if a value is specified otherwise return default value."""
    return value if len(value) > 0 else def_value


def has_child(root, element):
    """Checks if element contains another element."""
    eroot = element.getparent()
    if eroot == root:
        return True
    if eroot is None:
        return False
    return has_child(root, eroot)


def constraint_input(text, possible_inputs):
    """
    Constarint input to a predifined number of options
    """ 
    x = None
    while x is None:
        print(text, end='')
        x = input()
        if x not in possible_inputs:
            x = None
    return x


def set_variable(variable):
    """
    Lets user defining 
    """
    name = variable.text
    print(f' variable {name}')
    input_mode =  check_input(constraint_input('  use as (i:input, o:output) [i]: ', ['i','o','']), 'i')
    mode = VariableMode.OUTPUT if input_mode == 'o' else VariableMode.INPUT
    print(f'  value: ', end='') 
    value = input()
    return name, value, mode

def interactive_shell(name, test_path, def_author, def_frequency, def_description, variables=[]):
    """
    Generates a test JSON entry from user input.
    
    Parameters
    ----------
    - name: testcase name
    - test_path: relative path of the test qft file
    - def_author: default author
    - def_frequency: default frequency
    - def_description: default description
    - variables: list of external variables

    Returns
    -------
    - dict : JSON test case object
    """
    print(f'\nTest: {name}')

    print(" Enabled [y]: ", end="")
    if input() == "n":
        return None

    print(f" Author [{def_author}]:",end="")
    author = check_input(input(), def_author)

    done = False
    i = 0
    tests = []
    while not done:        
        id = name + ("" if i == 0 else f"_{i}")
        print(f" Description [{def_description}]: ", end="")
        description = check_input(input(), def_description)

        print(f" Frequency [{def_frequency}]: ", end="")
        frequency = check_input(input(), def_frequency)
        inputs = {}
        parameters = {}
        outputs = []
        if len(variables) > 0:
            defined = []
            for v in variables:
                if v.text not in defined:
                    name, value, mode = set_variable(v)
                    defined.append(name)
                    if mode == VariableMode.INPUT:
                        inputs[name] = value
                    else:
                        parameters[name] = value
                        outputs.append(value)

        tests.append({
                    "id": id,
                    "author": author,
                    "description": description,
                    "frequency": frequency,
                    "testPath": test_path,
                    "testCase": name,
                    "inputs" : inputs,
                    "parameters": parameters,
                    "outputs": outputs
                })
        i += 1
        done = True
        if len(variables):
            another_iteration = check_input(constraint_input(' define another instance for the same test? (y,n) [n] ', ['y','n','']), 'n')
            done = True if another_iteration == 'n' else False
            if not done:
                print()
    return tests


if __name__ == "__main__":
    # Setup argparse
    parser = argparse.ArgumentParser()
    parser.add_argument("testfile", help="QFT test file path")
    parser.add_argument("-a", "--author", default="autogenerated", help="Author of the test")
    parser.add_argument("-d", "--description", default="Auto generated test", help="Simple description of the test")
    parser.add_argument("-f", "--frequency", default="daily", help="Simple description of the test")
    parser.add_argument("-i", "--interactive", action="store_true", help="Enable interactive shell")
    parser.add_argument("-o", "--output", help="Output file")

    # Parse arguments 
    args = parser.parse_args()

    # Retrive the argument informations
    def_author = args.author
    def_description = args.description
    def_frequency = args.frequency
    interactive = args.interactive
    test_path = extract_path(args.testfile)
    
    # Check testPath is relative to SNAP-GUI-TESTS project
    if test_path is None:
        print(f"Error: path `{args.testfile}` is not inside the snap gui test project.")
        sys.exit(3)
    
    # Parse Test XML file
    tree = etree.parse(args.testfile)
    findTestCase = etree.XPath("//TestCase")
    findExtVariables = etree.XPath("//*[starts-with(text(),'@')]")

    # Iterate all the TestCase nodes
    test_lists = []
    for t in findTestCase(tree): 
        testcase = t.get('name')
        # Check if the test is enabled or not
        enabled = True
        if 'disabled' in t.attrib:
            enabled = not t.get('disabled')
        if enabled:      
            description = def_description
            variables = list(filter(lambda x: has_child(t,x), findExtVariables.evaluate(t)))
            description = t.get('reportname')
            # Add the test to the list of tests
            if interactive:
                testcase = interactive_shell(testcase, test_path, def_author, def_frequency, description, variables)
                if testcase is None:
                    continue
                test_lists += testcase
            else:
                defined = []
                inputs = {}
                parameters = {}
                outputs = []
                for v in variables:
                    if v.text not in defined:
                        name, value, mode = set_variable(v)
                        defined.append(name)
                        if mode == VariableMode.INPUT:
                            inputs[name] = value
                        else:
                            parameters[name] = value
                            outputs.append(value)
                test_lists.append({
                    "id": testcase,
                    "author": def_author,
                    "description": description,
                    "frequency": def_frequency,
                    "testPath": test_path,
                    "testCase": testcase,
                    "inputs" : inputs,
                    "parameters": parameters,
                    "outputs": outputs
                })
    if args.output is None:
        # If no output file is defined print the json structure 
        print(json.dumps(test_lists, indent=4))
    else:
        # Save json to defined file 
        with open(args.output, 'w') as f:
            f.write(json.dumps(test_lists, indent=4))